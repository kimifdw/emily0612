import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as n,a as e,b as r,d as i,e as o,r as d}from"./app.59944050.js";const c={},h=o('<h1 id="缓存问题-redis" tabindex="-1"><a class="header-anchor" href="#缓存问题-redis" aria-hidden="true">#</a> 缓存问题（Redis）</h1><h2 id="缓存踩踏" tabindex="-1"><a class="header-anchor" href="#缓存踩踏" aria-hidden="true">#</a> 缓存踩踏</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>多个线程试图并行访问缓存，如缓存的值不存在，则线程将同时尝试从数据源获取数据</p><h3 id="核心问题" tabindex="-1"><a class="header-anchor" href="#核心问题" aria-hidden="true">#</a> 核心问题</h3><p>竞态条件——多个线程争夺共享资源</p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><ol><li>增加更多的缓存</li><li>使用缓存异步 Promise 的模式来处理缓存</li><li>预先重计算【不推荐】。在缓存键正式过期前，重新计算缓存值并延长过期时间 <ul><li>概率性预先重计算。<code>currentTime-(timeToCompute*beta*log(rand())) &gt; expiry</code>。每当线程从缓存中获取数据时，都会执行这个算法。如果返回 true，那么该线程将重新计算这个缓存值。离过期时间越近，这个算法返回 true 的几率就会显著增加</li></ul><ol><li>currentTime 是当前时间戳。</li><li>timeToCompute 是重新计算缓存值所花费的时间。</li><li>beta 是一个大于 0 的非负数，默认值为 1，是可配置的。</li><li>rand()是一个返回 0 到 1 之间随机数的函数。</li><li>expiry 是缓存值未来被设置为过期的时间戳。</li></ol></li><li>回路断路器 <ul><li>将一个受保护的函数调用封装在一个断路器对象中，断路器对象负责监控故障，一旦故障达到某一阈值，断路器就跳闸，所有对断路器的进一步调用都返回错误，根本调用不到受保护的函数。</li></ul></li></ol><h3 id="资料" tabindex="-1"><a class="header-anchor" href="#资料" aria-hidden="true">#</a> 资料</h3>',9),s={href:"https://www.infoq.cn/article/Bb2YC0yHVSz4qVwdgZmO",target:"_blank",rel:"noopener noreferrer"},u={href:"https://cseweb.ucsd.edu/~avattani/papers/cache_stampede.pdf",target:"_blank",rel:"noopener noreferrer"};function p(_,f){const a=d("ExternalLinkIcon");return l(),n("div",null,[h,e("ol",null,[e("li",null,[e("a",s,[r("缓存踩踏：Facebook 史上最严重的宕机事件分析"),i(a)])]),e("li",null,[e("a",u,[r("概率性预先重计算论文"),i(a)])])])])}const b=t(c,[["render",p],["__file","index.html.vue"]]);export{b as default};
