import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as l,e as i}from"./app.59944050.js";const n="/assets/channel-4.1.53.b103cb4e.png",o="/assets/channel-pipline-flow.a40233d3.png",t="/assets/ChannelInboundHandler-api.58aa59d9.png",c="/assets/ChannelOutboundHandler-api.07341b8c.png",r="/assets/eventloop.49513c0c.png",d="/assets/NioEventLoop-start.be04f1d4.png",s="/assets/NioEventLoop-sequence.cd1f4292.png",h="/assets/NioEventLoop-Channel.32244483.png",p="/assets/Sequential-Access-Indexing.107c7e4a.png",u="/assets/discardReadBytes-flow.1ff78333.png",m="/assets/clearing-index.e9d69d30.png",g={},b=i('<h2 id="channel-源码" tabindex="-1"><a class="header-anchor" href="#channel-源码" aria-hidden="true">#</a> channel 源码</h2><ul><li>简介到网络套接字或 IO 操作的组件，如读、写、连接和绑定。类图如下： <img src="'+n+'" alt="image"></li></ul><ol><li><code>Unsafe</code>。用于数据传输</li><li><code>AbstractNioChannel</code>。NIO 的基本操作</li><li>通过<code>pipeline</code>来进行事件操作和流转。</li></ol><h2 id="channelpipeline" tabindex="-1"><a class="header-anchor" href="#channelpipeline" aria-hidden="true">#</a> ChannelPipeline</h2><blockquote><p>拦截器，维护 ChannelHandler 列表，类似于 servlet 和 filter 的关系</p></blockquote><h3 id="创建" tabindex="-1"><a class="header-anchor" href="#创建" aria-hidden="true">#</a> 创建</h3><ul><li>每个通道都有自己的管道，它会在创建新通道时自动创建</li></ul><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性" aria-hidden="true">#</a> 特性</h3><ol><li>支持运行时动态添加或删除<code>ChannelHandler</code>,线程安全</li></ol><h3 id="流程图如下" tabindex="-1"><a class="header-anchor" href="#流程图如下" aria-hidden="true">#</a> 流程图如下</h3><p><img src="'+o+'" alt="image"></p><ol><li><code>ChannelInboundHandler</code>。监控 Channel 状态变化，API 如下图所示： <img src="'+t+'" alt="image"></li><li><code>ChannelOutboundHandler</code>。拦截 IO 事件，API 如下图所示： <img src="'+c+'" alt="image"></li></ol><h2 id="eventloop" tabindex="-1"><a class="header-anchor" href="#eventloop" aria-hidden="true">#</a> Eventloop</h2><ul><li>处理注册在 channel 上的所有 IO 操作，事件循环器【单线程】,简单流程图如下： <img src="'+r+'" alt="image"></li></ul><ol><li><code>EventExecutor</code>。事件执行器，负责处理事件</li><li><code>EventExecutorGroup</code>。维护了一个 EventExecutor 链表，继承了 ScheduledExecutorService，execute 方法通过 next 方法选择一个 EventExecutor，并调用 EventLoop#execute 处理事件</li><li><code>EventloopGroup</code>。负责调度 Eventloop</li><li><code>NioEventloop</code>。 <ul><li>启动流程如下图： <img src="'+d+'" alt="image"></li><li>实例化流程图如下： <img src="'+s+'" alt="image"></li><li>与<code>Channel</code>的关联图如下： <img src="'+h+'" alt="image"></li></ul></li></ol><h2 id="bytebuf" tabindex="-1"><a class="header-anchor" href="#bytebuf" aria-hidden="true">#</a> ByteBuf</h2><h3 id="bytebuf-简介" tabindex="-1"><a class="header-anchor" href="#bytebuf-简介" aria-hidden="true">#</a> ByteBuf 简介</h3><ol><li>创建 buffer 使用 Unpooled 或 Pooled。</li><li><code>discardable bytes</code>。无效空间，可丢弃字节的区域</li><li><code>readable bytes</code>。内容空间，可读字节的区域，由 readerIndex 和 writerIndex 指针控制</li><li><code>writable bytes</code>。空闲空间，可写入字节的区域，由 writerIndex 指针和 capacity 容量控制</li><li>索引顺序存储。 <img src="'+p+'" alt="image"></li><li>Discardable bytes。回收未使用区域如下图所示： <img src="'+u+'" alt="image"></li><li>清除缓存索引。 <img src="'+m+'" alt="image"></li></ol><h2 id="fastthreadlocal" tabindex="-1"><a class="header-anchor" href="#fastthreadlocal" aria-hidden="true">#</a> FastThreadLocal</h2><ol><li><strong>ThreadLocal</strong>。每一个线程绑定了一个基于线性探测法的 HashMap 来存储数据，key 为当前 ThreadLocal 对象，通过 ThreadLocal 来定位所存储的 value</li><li><strong>FastThreadLocal</strong>。每一个 FastThreadLocalThread 线程绑定一个 Object[]数据来存储数据，FastThreadLocal 内部存储了一个索引值，利用该索引直接在数组中定位所存储的元素</li></ol>',20),_=[b];function f(x,v){return a(),l("div",null,_)}const I=e(g,[["render",f],["__file","index.html.vue"]]);export{I as default};
