import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as l,e as a}from"./app.59944050.js";const o={},r=a('<h1 id="数据库引擎" tabindex="-1"><a class="header-anchor" href="#数据库引擎" aria-hidden="true">#</a> 数据库引擎</h1><h2 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb" aria-hidden="true">#</a> InnoDB</h2><h3 id="一、buffer-pool" tabindex="-1"><a class="header-anchor" href="#一、buffer-pool" aria-hidden="true">#</a> 一、Buffer Pool</h3><h4 id="_1-1-组件" tabindex="-1"><a class="header-anchor" href="#_1-1-组件" aria-hidden="true">#</a> 1.1 组件</h4><ul><li>数据页。MySQL数据以页为单位，每页默认<strong>16KB</strong>。</li><li>描述数据。缓存页的元数据信息，包含【表空间、数据号、地址等、下个free节点引用、下个flush节点引用、下个LRU节点引用】</li><li>WAL技术【Write-Ahead-Logging】。通过<code>redo log</code>让MySQL拥有了崩溃恢复能力</li><li>脏页。直接更新数据的缓存页</li><li>干净页。缓存页刷盘后</li><li>free链表。使用链表结构，将空闲缓存页的描述数据放入链表。</li><li>缓存页哈希表。key：表空间号+数据页号；value：缓存页的地址。</li><li>flush链表。存储缓存页变化的描述数据。</li><li>LRU链表。最少使用的缓存页淘汰【命中率低】，最近访问的数据一定在链表头部 <ul><li>热区域【<code>young</code>区域】</li><li>冷区域【<code>old区域</code>】</li></ul></li><li>预读机制。加载数据页时，可能会把它相邻的数据页一并加载进来【局部性原理】</li></ul>',5),d=[r];function n(h,t){return i(),l("div",null,d)}const f=e(o,[["render",n],["__file","db-engine.html.vue"]]);export{f as default};
