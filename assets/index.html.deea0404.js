import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c,e as l}from"./app.59944050.js";const i="/assets/single-thread-reactor.c10b73ef.png",a="/assets/worker-thread-pool-reactor.023992aa.png",r="/assets/multiple-reactors.22e570e4.png",t="/assets/buffer-mode.b6ab2a09.png",n="/assets/nio-server-sequence.7c0cc2f6.png",d={},s=l('<h1 id="reactor-模型" tabindex="-1"><a class="header-anchor" href="#reactor-模型" aria-hidden="true">#</a> reactor 模型</h1><h2 id="单线程-reactor-模型" tabindex="-1"><a class="header-anchor" href="#单线程-reactor-模型" aria-hidden="true">#</a> 单线程 reactor 模型</h2><p><img src="'+i+'" alt="image"></p><h3 id="java-nio-support" tabindex="-1"><a class="header-anchor" href="#java-nio-support" aria-hidden="true">#</a> java nio support</h3><ol><li><code>Channels</code>。连接文件、socket 等支持非阻塞读取</li><li><code>Buffers</code>。表示直接从<code>channels</code>中读取或写入的数组对象</li><li><code>Selectors</code>。表示哪些<code>Channel</code>集合存在 IO 事件</li><li><code>SelectionKeys</code>。用于维持 IO 事件的状态和绑定关系</li></ol><h2 id="多线程单-reactor-模型" tabindex="-1"><a class="header-anchor" href="#多线程单-reactor-模型" aria-hidden="true">#</a> 多线程单 reactor 模型</h2><p><img src="'+a+'" alt="image"></p><ul><li>工作线程。reactors 需要快速触发 handlers,非 IO 处理转移到其他线程上</li></ul><h2 id="多线程多-reactor-模型" tabindex="-1"><a class="header-anchor" href="#多线程多-reactor-模型" aria-hidden="true">#</a> 多线程多 reactor 模型</h2><p><img src="'+r+'" alt="image"></p><ul><li>由主 acceptor 分配到其他 reactor 去处理，子reactor进行socket读写操作</li></ul><h1 id="nio-其他功能" tabindex="-1"><a class="header-anchor" href="#nio-其他功能" aria-hidden="true">#</a> nio 其他功能</h1><ol><li>支持每个 reactor 包含多个 selectors，简单流程介绍如下：向一个 Selector 中注册了 Channel 后，由 selector 自动来判断查询这些 channel 是否有已就绪的 IO 事件</li><li>文件转移。自动化从文件到网络或网络到文件的拷贝</li><li>内存文件映射。利用<code>buffers</code>来处理文件，<code>channel</code>总是从<code>Buffer</code>中读取数据或写入数据</li><li><code>Buffer</code>。数据是通道读入缓冲区，从缓冲区写入到通道中的。 <ol><li>流程。写入数据到 buffer——&gt;调用 flip()方法【读写切换】——&gt;从 buffer 中读取数据——&gt;数据清理 clear()/compact()</li><li>工作原理。 <img src="'+t+'" alt="image"> 1. <code>capacity</code>。缓冲区的固定大小。 1. <code>position</code>。 - 写操作。当前位置，初始化为 0，最大为 capacity-1 - 读操作。读取特定位置读，写模式切换到读模式，position 重置为 0 1. <code>limit</code>。 - 写操作。最多能往 buffer 里写多少数据 - 读操作。最多能读到多少数据，能读到 position 的数据</li></ol></li><li><code>Direct buffers</code>。 <ol><li>支持零拷贝；</li><li>在开启或结束时有开销，所分配的内存不在 JVM 堆上；</li><li>用于长连接。</li></ol></li><li><code>Non-Direct Buffer</code>。 <ol><li>直接在 JVM 堆上进行内存的分配。本质为 byte[]数组</li><li>存在内存拷贝问题，效率低</li></ol></li><li><code>Channel</code>类型 <ol><li>FileChannel：文件操作【同步】</li><li>DatagramChannel：UDP 操作</li><li>SocketChannel：TCP 操作</li><li>ServerSocketChannel：TCP 操作，使用在服务器端</li></ol></li><li><code>Channel事件</code><ol><li>Connect, 即连接事件(TCP 连接), 对应于 SelectionKey.OP_CONNECT</li><li>Accept, 即确认事件, 对应于 SelectionKey.OP_ACCEPT</li><li>Read, 即读事件, 对应于 SelectionKey.OP_READ, 表示 buffer 可读.</li><li>Write, 即写事件, 对应于 SelectionKey.OP_WRITE, 表示 buffer 可写.</li></ol></li><li><code>Selector</code>的基本使用流程 <img src="'+n+'" alt="image"> 1. 通过<code>Selector.open()</code>打开一个<code>Selector</code>. 1. 将<code>Channel</code>注册到<code>Selector</code>中, 并设置需要监听的事件(interest set) 1. 不断重复: - 调用<code>select()</code>方法 - 调用<code>selector.selectedKeys()</code>获取 selected keys - 迭代每个 selected key: - 从<code>selected key</code>中获取 对应的<code>Channel</code>和附加信息(如果有的话) - 判断是哪些 IO 事件已经就绪了, 然后处理它们. <strong>如果是 OP_ACCEPT 事件, 则调用 &quot;SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept()&quot; 获取 SocketChannel, 并将它设置为 非阻塞的, 然后将这个 Channel 注册到 Selector 中.</strong> - 根据需要更改 selected key 的监听事件. - 将已经处理过的 key 从 selected keys 集合中删除.</li></ol>',13),h=[s];function f(p,u){return o(),c("div",null,h)}const C=e(d,[["render",f],["__file","index.html.vue"]]);export{C as default};
