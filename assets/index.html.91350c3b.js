import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c,a as n,b as a,d as e,e as p,r as l}from"./app.59944050.js";const i="/assets/atomicIntegerArray.0c744e74.png",r={},u=p(`<h1 id="atomic-包" tabindex="-1"><a class="header-anchor" href="#atomic-包" aria-hidden="true">#</a> atomic 包</h1><h2 id="unsafe-类" tabindex="-1"><a class="header-anchor" href="#unsafe-类" aria-hidden="true">#</a> unsafe 类</h2><ol><li>封装了直接对内存管理、操纵对象、阻塞/唤醒线程等操作</li><li>native 方法，需要通过 CAS 原子指令完成</li><li>类加载器 <ol><li><code>Bootstrap类加载器</code>。主要加载的是 JVM 自身需要的类</li><li><code>Extension ClassLoader扩展类加载器</code>。负责加载 ext 目录下的类库</li><li><code>Application ClassLoader系统类加载器</code>。负责加载用户类路径所指定的类</li></ol></li><li><code>compareAndSwapInt</code>中的偏移量字段是为了更方便的查找对象</li></ol><h2 id="atomicinteger-atomicboolean-atomiclong-类" tabindex="-1"><a class="header-anchor" href="#atomicinteger-atomicboolean-atomiclong-类" aria-hidden="true">#</a> AtomicInteger/AtomicBoolean/AtomicLong 类</h2><blockquote><p>三个类只是操作的类型不一样，原理上一致</p></blockquote><ol><li>初始化</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// value偏移量值的获取</span>
            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span>objectFieldOffset
                <span class="token punctuation">(</span><span class="token class-name">AtomicInteger</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;value&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>特殊方法 <ul><li><code>lazySet</code>。通过共享变量来改变值，与普通操作变量的方式类似。适用于加锁的场景，可以减少不必要的内存屏障</li></ul></li></ol><h2 id="atomicreference" tabindex="-1"><a class="header-anchor" href="#atomicreference" aria-hidden="true">#</a> AtomicReference</h2><ol><li>引入类似乐观锁的方式操作共享资源，而非使用锁的方式（悲观）</li><li>提供了以无锁方式访问共享资源的能力，以自旋和 CAS 的方式来解决共享变量的线程安全问题</li><li>比较的是对象的引用</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ref<span class="token punctuation">;</span>

    <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> ref<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//自旋操作</span>
            <span class="token class-name">Integer</span> oldV <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>oldV<span class="token punctuation">,</span> oldV <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// CAS操作</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="atomicstampedreference" tabindex="-1"><a class="header-anchor" href="#atomicstampedreference" aria-hidden="true">#</a> AtomicStampedReference</h2><blockquote><p>加了版本号的<code>AtomicReference</code>，可以用来解决 CAS 的 ABA 问题</p></blockquote><h2 id="atomicmarkablereference" tabindex="-1"><a class="header-anchor" href="#atomicmarkablereference" aria-hidden="true">#</a> AtomicMarkableReference</h2><blockquote><p>能识别引用变量是否被更改过，使用<strong>boolean</strong>来标识是否有改过，功能与 AtomicStampedReference 类似</p></blockquote><h2 id="atomicintegerarray-atomiclongarray-atomicreferencearray" tabindex="-1"><a class="header-anchor" href="#atomicintegerarray-atomiclongarray-atomicreferencearray" aria-hidden="true">#</a> AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray</h2><ol><li>以原子的方式操作数组中的元素</li><li>初始化</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取数组中每个元素的占用内存大小</span>
        <span class="token keyword">int</span> scale <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">arrayIndexScale</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>scale <span class="token operator">&amp;</span> <span class="token punctuation">(</span>scale <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;data type scale not a power of two&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 从最左边起，连续0的个数</span>
        shift <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">-</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span>scale<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>计算公式 <img src="`+i+'" alt="image"></li></ol><h2 id="longaddr-1-8" tabindex="-1"><a class="header-anchor" href="#longaddr-1-8" aria-hidden="true">#</a> LongAddr/（1.8）</h2><ol><li>多线程唤醒下会比 AtomicLong 的吞吐量高，典型的以空间换时间</li><li>实现思路。<strong>分散热点</strong>，将 value 值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行<strong>CAS</strong>操作，减小冲突概率。最后再将值累加起来；只能每次对给定的整数执行一次加法</li><li><code>LongAccumulator</code>。实现思路与<code>LongAddr</code>类似，区别在于可实现任意函数操作</li><li>资料</li></ol>',21),d={href:"https://segmentfault.com/a/1190000015865714",target:"_blank",rel:"noopener noreferrer"},k={href:"http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/",target:"_blank",rel:"noopener noreferrer"},m=n("h2",{id:"资料",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#资料","aria-hidden":"true"},"#"),a(" 资料")],-1),v={href:"https://segmentfault.com/a/1190000015831791",target:"_blank",rel:"noopener noreferrer"},h={href:"https://blog.csdn.net/aesop_wubo/article/details/7537278",target:"_blank",rel:"noopener noreferrer"};function b(f,g){const s=l("ExternalLinkIcon");return o(),c("div",null,[u,n("ul",null,[n("li",null,[n("a",d,[a("Java 多线程进阶（十七）—— J.U.C 之 atomic 框架：LongAdder"),e(s)])]),n("li",null,[n("a",k,[a("atomicLong vs LongAddr"),e(s)])])]),m,n("ol",null,[n("li",null,[n("a",v,[a("atomic"),e(s)])]),n("li",null,[n("a",h,[a("unsafe 包说明"),e(s)])])])])}const _=t(r,[["render",b],["__file","index.html.vue"]]);export{_ as default};
