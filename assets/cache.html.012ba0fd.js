import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as d,a as e,b as a,d as n,e as r,r as l}from"./app.59944050.js";const o="/image/1.png",h={},c=r('<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><h2 id="一、redis与mysql双写一致性" tabindex="-1"><a class="header-anchor" href="#一、redis与mysql双写一致性" aria-hidden="true">#</a> 一、Redis与MySQL双写一致性</h2><h3 id="_1-1-一致性" tabindex="-1"><a class="header-anchor" href="#_1-1-一致性" aria-hidden="true">#</a> 1.1 一致性</h3><p><strong>强一致性</strong>。这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</p><p><strong>弱一致性</strong>。这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</p><p><strong>最终一致性</strong>。是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。</p><h3 id="_1-2-缓存模式" tabindex="-1"><a class="header-anchor" href="#_1-2-缓存模式" aria-hidden="true">#</a> 1.2 缓存模式</h3><ol><li><p>Cache-Aside Pattern【旁路缓存模式】。为了尽可能地解决缓存与数据库的数据不一致问题。</p><p>流程：</p><ol><li>读取。先读缓存，再去读数据库，从数据库取出数据，放入缓存，同时返回响应</li><li>写入。<strong>先更新数据库，然后再删除缓存</strong></li></ol></li><li><p>Read-Through/Write-Through【读写穿透】。服务端把缓存作为主要数据存储。也就是在Cache-Aside Pattern中增加了一个cache provider，由这个provider来处理缓存与数据库的交互</p></li><li><p>Write-behind【异步缓存写入】。与读写穿透类似，只是在操作数据库的时候采用<strong>异步批量更新</strong>数据库的方式</p></li></ol><h3 id="_1-3-操作缓存" tabindex="-1"><a class="header-anchor" href="#_1-3-操作缓存" aria-hidden="true">#</a> 1.3 操作缓存</h3><ol><li>一般采用先更新数据库再删除缓存</li><li>缓存延时双删。先删除缓存--&gt;再更新数据库--&gt;休眠一会儿，再删除缓存</li><li>删除缓存重试机制</li><li>读取<strong>binlog</strong>异步删除缓存</li></ol><h3 id="_1-4-参考文献" tabindex="-1"><a class="header-anchor" href="#_1-4-参考文献" aria-hidden="true">#</a> 1.4 参考文献</h3>',11),p={href:"https://mp.weixin.qq.com/s/c0JwYl-9prOLtNeoTTch0w",target:"_blank",rel:"noopener noreferrer"},u=r('<h2 id="二、大key与热key" tabindex="-1"><a class="header-anchor" href="#二、大key与热key" aria-hidden="true">#</a> 二、大Key与热Key</h2><h3 id="_2-1-定义。" tabindex="-1"><a class="header-anchor" href="#_2-1-定义。" aria-hidden="true">#</a> 2.1 定义。</h3><p>大Key。以数据大小与成员数量来判定，会将含有较大数据或含有大量成员、列表数的Key【根据实际使用场景、业务场景来判断】</p><ul><li><p>一个<strong>STRING</strong>类型的Key，它的值为<strong>5MB</strong>（数据过大）</p></li><li><p>一个<strong>LIST</strong>类型的Key，它的列表数量为<strong>20000</strong>个（列表数量过多）</p></li><li><p>一个<strong>ZSET</strong>类型的Key，它的成员数量为<strong>10000</strong>个（成员数量过多）</p></li><li><p>一个<strong>HASH</strong>格式的Key，它的成员数量虽然只有<strong>1000</strong>个但这些成员的value总大小为<strong>100MB</strong>（成员体积过大）</p></li></ul><p>热Key。在某个Key接收到的访问次数、显著高于其它Key。</p><h3 id="_2-2-问题排查" tabindex="-1"><a class="header-anchor" href="#_2-2-问题排查" aria-hidden="true">#</a> 2.2 问题排查</h3><p><img src="'+o+'" alt="问题排查"></p><h3 id="_2-3-方法处理" tabindex="-1"><a class="header-anchor" href="#_2-3-方法处理" aria-hidden="true">#</a> 2.3 方法处理</h3><ol><li>读写分离架构</li></ol><h3 id="_2-4-参考文献" tabindex="-1"><a class="header-anchor" href="#_2-4-参考文献" aria-hidden="true">#</a> 2.4 参考文献</h3>',10),_={href:"https://mp.weixin.qq.com/s/FPYE1B839_8Yk1-YSiW-1Q",target:"_blank",rel:"noopener noreferrer"},g=r('<h2 id="三、redis总结" tabindex="-1"><a class="header-anchor" href="#三、redis总结" aria-hidden="true">#</a> 三、redis总结</h2><h3 id="_3-1-redis数据类型剖析" tabindex="-1"><a class="header-anchor" href="#_3-1-redis数据类型剖析" aria-hidden="true">#</a> 3.1 redis数据类型剖析</h3><h4 id="_3-1-1-string" tabindex="-1"><a class="header-anchor" href="#_3-1-1-string" aria-hidden="true">#</a> 3.1.1 string</h4><blockquote><p>sds数据结构，采用<strong>空间预分配</strong>和<strong>惰性空间</strong>释放来提升效率。核心是空间换时间</p></blockquote><h4 id="_3-1-2-list" tabindex="-1"><a class="header-anchor" href="#_3-1-2-list" aria-hidden="true">#</a> 3.1.2 list</h4><h4 id="_3-1-3-hash" tabindex="-1"><a class="header-anchor" href="#_3-1-3-hash" aria-hidden="true">#</a> 3.1.3 hash</h4><h4 id="_3-1-4-zset" tabindex="-1"><a class="header-anchor" href="#_3-1-4-zset" aria-hidden="true">#</a> 3.1.4 zset</h4><blockquote><p>有序集合，底层采用跳跃表实现</p></blockquote><h4 id="_3-1-5-set" tabindex="-1"><a class="header-anchor" href="#_3-1-5-set" aria-hidden="true">#</a> 3.1.5 set</h4><h3 id="_3-2-持久化方案" tabindex="-1"><a class="header-anchor" href="#_3-2-持久化方案" aria-hidden="true">#</a> 3.2 持久化方案</h3><h4 id="_3-2-1-rdb" tabindex="-1"><a class="header-anchor" href="#_3-2-1-rdb" aria-hidden="true">#</a> 3.2.1 rdb</h4><ol><li>save。手动保存，阻塞进程，直至RDB文件创建完毕</li><li>bgsave。与save不同的是可以不阻塞redis进程</li></ol><h4 id="_3-2-2-aof" tabindex="-1"><a class="header-anchor" href="#_3-2-2-aof" aria-hidden="true">#</a> 3.2.2 aof</h4><blockquote><p>命令追加的模式</p></blockquote><h3 id="_3-3-缓存穿透、击穿、雪崩如何解决" tabindex="-1"><a class="header-anchor" href="#_3-3-缓存穿透、击穿、雪崩如何解决" aria-hidden="true">#</a> 3.3 缓存穿透、击穿、雪崩如何解决</h3><h4 id="_3-3-1-缓存穿透" tabindex="-1"><a class="header-anchor" href="#_3-3-1-缓存穿透" aria-hidden="true">#</a> 3.3.1 缓存穿透</h4><p>问题。处理缓存和DB都不存在的数据时</p><p>解决方案</p><ol><li>空值缓存</li><li>布隆过滤器。在有限的空间里，通过多个hash函数来定位一条数据</li></ol><h4 id="_3-3-2-缓存击穿【单个key】" tabindex="-1"><a class="header-anchor" href="#_3-3-2-缓存击穿【单个key】" aria-hidden="true">#</a> 3.3.2 缓存击穿【单个KEY】</h4><p>问题。热点数据在某一时刻缓存过期，然后突然大量请求打到db中，这时如果db扛不住，可能就挂了，引起线上连锁反应。类似并发访问一些热点数据</p><p>解决方案</p><ol><li>并发问题。加分布式锁</li><li>配置二级缓存【内存或借助其他缓存工具】</li><li>热点数据不过期</li></ol><h4 id="_3-3-3-缓存雪崩【多个key】" tabindex="-1"><a class="header-anchor" href="#_3-3-3-缓存雪崩【多个key】" aria-hidden="true">#</a> 3.3.3 缓存雪崩【多个KEY】</h4><p>问题。某一时间点，突然大量缓存失效，所有的请求都打到了db</p><p>解决方案。</p><ol><li>随机设置失效时间。防止在某一个时间点大批量缓存失效</li><li>上锁：根据场景上锁，保护db</li><li>二级缓存：同缓存击穿</li><li>热点数据不过期：同缓存击穿</li></ol><h3 id="_3-4-参考文献" tabindex="-1"><a class="header-anchor" href="#_3-4-参考文献" aria-hidden="true">#</a> 3.4 参考文献</h3>',28),b={href:"https://mp.weixin.qq.com/s/HINQmFmkWXXhI5_D07tyBw",target:"_blank",rel:"noopener noreferrer"},m=r(`<h2 id="四、排查redis查询慢的问题" tabindex="-1"><a class="header-anchor" href="#四、排查redis查询慢的问题" aria-hidden="true">#</a> 四、排查redis查询慢的问题</h2><h3 id="_4-1-设置redis的慢日志阀值" tabindex="-1"><a class="header-anchor" href="#_4-1-设置redis的慢日志阀值" aria-hidden="true">#</a> 4.1 设置Redis的慢日志阀值</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 命令执行超过5毫秒记录慢日志</span>
CONFIG SET slowlog-log-slower-than <span class="token number">5000</span>
<span class="token comment"># 记录最近1000条慢日志</span>
CONFIG SET slow-max-len <span class="token number">1000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体执行显示如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>uat:<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>slowlog get <span class="token number">5</span>
 <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token string">&quot;18394&quot;</span>  <span class="token comment"># 慢日志ID</span>
  <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token string">&quot;1630483150&quot;</span>  <span class="token comment"># 执行时间</span>
  <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token string">&quot;112466&quot;</span>      <span class="token comment"># 执行耗时(微妙)</span>
  <span class="token number">4</span><span class="token punctuation">)</span>      <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token string">&quot;KEYS&quot;</span> <span class="token comment"># 具体执行的命令和参数</span>
   <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token string">&quot;ims:mc:unreadMsgKey*&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-考虑方向" tabindex="-1"><a class="header-anchor" href="#_4-2-考虑方向" aria-hidden="true">#</a> 4.2 考虑方向</h3><ol><li>大key存储【比如在慢日志中出现ZSET等】</li><li>出现key集中过期的情况</li><li>实例内存达到上线</li><li>fork耗时严重。主要是看lastest_fork_usec耗时，这个耗时表示在这段时间内整个实例是阻塞无法处理请求的时间，类似于JAVA的STW</li><li>绑定CPU【如开启了AOF和RDB，则不能绑定CPU】</li><li>开启AOF</li><li>使用SWAP【redis使用的内存被切换到了磁盘上】，这种场景一般是出现在服务器本身内存不足而用到了swap的情况</li><li>网卡负载过高</li></ol><h3 id="_4-3-总结" tabindex="-1"><a class="header-anchor" href="#_4-3-总结" aria-hidden="true">#</a> 4.3 总结</h3><ol><li>开发人员。我们需要了解Redis的<strong>运行机制</strong>，例如各个命令的执行时间复杂度、数据过期策略、<strong>数据淘汰策略</strong>等，使用合理的命令，并结合业务场景进行优化</li><li>运维人员。需要了解<strong>数据持久化</strong>、<strong>操作系统fork原理</strong>、<strong>Swap机制</strong>等，并对Redis的容量进行合理规划，预留足够的机器资源，对机器做好<strong>完善的监控</strong>，才能保证Redis的稳定运行。</li></ol><h3 id="_4-4-参考资料" tabindex="-1"><a class="header-anchor" href="#_4-4-参考资料" aria-hidden="true">#</a> 4.4 参考资料</h3>`,10),k={href:"https://mp.weixin.qq.com/s/paeQZMs7TrXd8oC1Pz8yYQ",target:"_blank",rel:"noopener noreferrer"};function f(x,v){const s=l("ExternalLinkIcon");return t(),d("div",null,[c,e("ol",null,[e("li",null,[e("a",p,[a("Redis与MySQL双写一致性"),n(s)])])]),u,e("ol",null,[e("li",null,[e("a",_,[a("一文详解Redis中BigKey、HotKey的发现与处理"),n(s)])])]),g,e("ol",null,[e("li",null,[e("a",b,[a("redis总结"),n(s)])])]),m,e("ul",null,[e("li",null,[a("[x] "),e("a",k,[a("redis变慢，如何快速排查"),n(s)])])])])}const K=i(h,[["render",f],["__file","cache.html.vue"]]);export{K as default};
