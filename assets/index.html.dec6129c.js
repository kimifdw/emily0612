import{_ as r}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c as n,a as e,b as l,d as a,e as t,r as c}from"./app.59944050.js";const d="/assets/memory-heap.5537aa42.png",s="/assets/import-property.76d70e33.png",h="/assets/remark-life.5019631f.png",g="/assets/overflow-log.9727a802.png",u={},p=t('<h1 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h1><p>一种server-style的垃圾收集器，适用于具有大内存的多处理器计算器</p><h1 id="名词定义" tabindex="-1"><a class="header-anchor" href="#名词定义" aria-hidden="true">#</a> 名词定义</h1><ol><li>Garbage-First。执行并发全局标记，以确定整个堆中对象的活动性，进而了解哪些区域为空，优先收集区域为空较多的区域。即将收集和压缩活动集中在可能充满可回收对象的堆区域中</li><li>并发收集模式问题。 <ol><li>应用程序分配对象的速度超过垃圾收集器可以回收可用空间的速度</li><li>可用空闲空间块无法满足分配要求</li></ol></li><li>SATB。快照技术来找到所有活动对象，类似于CMS增量更新，采用三色标记算法。 <ol><li>白。对象没有被标记，标记阶段结束后，会被当做垃圾回收掉</li><li>灰。对象被标记，它的field还没有被标记或标记完</li><li>黑。对象被标记，且它的所有field也被标记完了</li></ol></li><li>卡表。Java HotSpot VM使用字节数组作为卡表，每个字节称为卡，卡与堆中的地址范围相对应。是RSet的一种实现</li><li>Humongous object。任何<strong>大于区域大小一半</strong>的对象，被直接分配到了老年代区域。</li><li>RSet【Remembered Set】。用于记录从非收集部分指向收集部分的指针集合的抽象数据结构【partial GC】。辅助GC过程的一种结构，典型的空间换时间工具。</li><li>CSet【Collection Set】。记录了GC要收集的Region集合，集合里的Region是任意年代的。</li><li>分区垃圾收集器的特征。可以自由选择任意多个region来独立收集构成收集集合（CSet），靠RSet实现。</li></ol><h1 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h1><ol><li>将对象从堆的一个或多个区域复制到堆上的单个区域，并在此过程中压缩和释放内存</li><li>不断减少碎片</li><li>为运行需要大型堆（<strong>6GB或更大</strong>）且GC延迟有限的应用程序的用户提供解决方案，可预测的暂停时间低于0.5s</li></ol><h1 id="cms-g1" tabindex="-1"><a class="header-anchor" href="#cms-g1" aria-hidden="true">#</a> CMS=&gt;G1</h1><ol><li>JAVA堆被实时数据占用&gt;=50%</li><li>对象分配率或提升率差异很大</li><li>长时间垃圾收集或压缩暂停&gt;0.5s</li></ol><h1 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点" aria-hidden="true">#</a> 注意点</h1><p>G1非实时收集器。</p><h1 id="堆分区" tabindex="-1"><a class="header-anchor" href="#堆分区" aria-hidden="true">#</a> 堆分区</h1><blockquote><p>Java对象堆被划分为多个大小相等的区域，1MB~32MB不等，不超过2048个区域，内存布局如下图所示</p></blockquote><p><img src="'+d+'" alt="image"></p><ol><li>年轻代。浅蓝色区域</li><li>混合集合。深蓝色的旧区域</li><li>正在收集部分。红色框标记</li><li>幸存者区域。标有S</li><li>巨大对象。标有H，在cleanup和Full gc阶段回收</li></ol><h1 id="暂停-stw" tabindex="-1"><a class="header-anchor" href="#暂停-stw" aria-hidden="true">#</a> 暂停(STW)</h1><ol><li>年轻代STW只发生在年轻代</li><li>mixed collection pauses.处理年轻代和老年代混合部分</li></ol><h1 id="启用方式" tabindex="-1"><a class="header-anchor" href="#启用方式" aria-hidden="true">#</a> 启用方式</h1><ol><li><code>-XX:+UseG1GC</code></li><li><code>-XX:+ParallelGCThreads=&lt;N&gt;</code>。STW的工作线程数量，与服务器的核数有关，默认值按(cpu &lt;= 8) ? cpu : 3 + ((cpu * 5) / 8)</li><li><code>-XX:G1MixedGCLiveThresholdPercent=&lt;N&gt;</code>。混合垃圾收集器中旧区域的占用阀值。</li><li><code>-XX:+UnlockExperimentalVMOptions</code>。解锁实验性标志的值</li><li>其他默认重要的参数配置 <img src="'+s+'" alt="image"></li></ol><h1 id="垃圾收集" tabindex="-1"><a class="header-anchor" href="#垃圾收集" aria-hidden="true">#</a> 垃圾收集</h1><h2 id="全局并发标记-global-concurrent-marking" tabindex="-1"><a class="header-anchor" href="#全局并发标记-global-concurrent-marking" aria-hidden="true">#</a> 全局并发标记（global concurrent marking)</h2><p><img src="'+h+'" alt="image"> 基于SATB形式的并发标记</p><ol><li>Initial marking phase（初始标记阶段，<strong>暂停阶段</strong>）。扫描根集合，标记所有从根集合可直接达到的对象并将它们的字段压入扫描栈中等到后续扫描。年轻代垃圾回收器承载，不额外进行处理。</li><li>Root region scanning phase（根区域扫描阶段）。扫描初始标记阶段标记的幸存者区域</li><li>Concurrent marking phase（<strong>并发标记阶段</strong>）。查找整个堆中可访问的活动的对象。</li><li>Remark phase（标记阶段，<strong>暂停阶段</strong>）。STW收集</li><li>Cleanup phase（<strong>清理阶段【并发】</strong>）。执行计费和RSet清理的STW操作,清理部分为并发完成。</li></ol><h2 id="拷贝存活对象-evacuation" tabindex="-1"><a class="header-anchor" href="#拷贝存活对象-evacuation" aria-hidden="true">#</a> 拷贝存活对象（evacuation）</h2><ol><li>全暂停的。负责把一部分region里的活对象拷贝到空region里取，然后回收原本的region的空间。</li><li>分区垃圾收集器的特征。可以自由选择任意多个region来独立收集构成收集集合（CSet），靠RSet实现。</li></ol><h1 id="收集周期" tabindex="-1"><a class="header-anchor" href="#收集周期" aria-hidden="true">#</a> 收集周期</h1><h2 id="混合收集" tabindex="-1"><a class="header-anchor" href="#混合收集" aria-hidden="true">#</a> 混合收集</h2><ol><li>选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region</li><li><strong>并非FULL GC</strong>，只能回收部分老年代的分区</li></ol><h2 id="年轻代" tabindex="-1"><a class="header-anchor" href="#年轻代" aria-hidden="true">#</a> 年轻代</h2><ol><li>收集eden regions和survivor regions</li><li>特定对象的目标区域取决于对象的年龄，升级到老年代</li><li>对象包含在下一个年轻代或混合垃圾收集的CSet</li><li>通过控制young gen的region个数来控制young GC的开销。</li><li><strong>young gen region总是在CSet内</strong></li></ol><h1 id="推荐建议" tabindex="-1"><a class="header-anchor" href="#推荐建议" aria-hidden="true">#</a> 推荐建议</h1><ol><li>年轻代大小。避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>来显示设置年轻代大小</li><li>暂停时间目标。 <ol><li>G1 GC的吞吐量目标是90%的应用时间+10%的垃圾收集时间</li><li>并行收集器的吞吐量目标是99%的应用时间+1%的垃圾收集时间</li></ol></li><li>混合垃圾收集。 <ol><li><code>-XX：InitiatingHeapOccupancyPercent</code>。用于更改标记阈值。</li><li><code>-XX：G1MixedGCLiveThresholdPercent</code>和<code>-XX：G1HeapWastePercent</code>。用于更改混合垃圾回收决策。</li><li><code>-XX：G1MixedGCCountTarget</code>和<code>-XX：G1OldCSetRegionThresholdPercent</code>。用于调整旧区域的CSet</li></ol></li></ol><h1 id="gc问题日志" tabindex="-1"><a class="header-anchor" href="#gc问题日志" aria-hidden="true">#</a> GC问题日志</h1><p>overflow日志 <img src="'+g+'" alt="image"></p><ol><li>原因。内存不足</li><li>解决方案 <ol><li>增加<code>-XX：G1ReservePercent</code>选项的值（并相应增加总堆），以增加reserve memory 的保留内存量。</li><li>通过减小<code>-XX：InitiatingHeapOccupancyPercent</code>的值来更早地开始标记周期。</li><li>增加<code>-XX：ConcGCThreads</code>选项的值，以增加并行标记线程的数量。</li></ol></li></ol><h1 id="资料参考" tabindex="-1"><a class="header-anchor" href="#资料参考" aria-hidden="true">#</a> 资料参考</h1>',35),m={href:"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#humongous",target:"_blank",rel:"noopener noreferrer"},f={href:"https://cloud.tencent.com/developer/article/1459638",target:"_blank",rel:"noopener noreferrer"};function b(_,x){const i=c("ExternalLinkIcon");return o(),n("div",null,[p,e("ol",null,[e("li",null,[e("a",m,[l("Garbage-First Garbage Collector Tuning"),a(i)])]),e("li",null,[e("a",f,[l("详解 JVM Garbage First(G1) 垃圾收集器"),a(i)])])])])}const X=r(u,[["render",b],["__file","index.html.vue"]]);export{X as default};
