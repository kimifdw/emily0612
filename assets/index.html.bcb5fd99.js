import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as t,a as e,b as l,d as r,e as n,r as d}from"./app.59944050.js";const s="/assets/struct.d3dc8c4e.png",h="/assets/architecture.34328524.png",c={},p=n('<h2 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h2><p>在分布式系统中协作多个任务</p><h2 id="进程间通信" tabindex="-1"><a class="header-anchor" href="#进程间通信" aria-hidden="true">#</a> 进程间通信</h2><p>使用共享存储模型，即开发的应用是从连接到 zookeeper 服务器端的客户端，他们连接到 zookeeper 服务器进行相关的操作，来影响服务器端存储的共享数据，最终应用间实现协作</p><h2 id="不适合的场景" tabindex="-1"><a class="header-anchor" href="#不适合的场景" aria-hidden="true">#</a> 不适合的场景</h2><p>海量数据存储</p><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h2><ol><li>采用类似文件系统的层级树状结构管理 Znode</li><li>Znode 的节点类型。 1. 在新建 znode 节点。需要指定该节点的类型，不同的类型决定了 znode 节点的行为方式，znode 的类型分为<strong>持久节点</strong>、<strong>时节点</strong>、<strong>有序节点</strong>，<strong>组合</strong> 4 中类型，持久的，临时的，持久有序的，临时有序的 <img src="'+s+'" alt="image"> 2. 持久节点。只能主动删除 3. 临时节点。该节点的客户端崩溃或关闭连接时会删除 4. 有序节点。被分配唯一一个单调递增的整数</li></ol><h2 id="监视和通知" tabindex="-1"><a class="header-anchor" href="#监视和通知" aria-hidden="true">#</a> 监视和通知</h2><p>客户端获得服务器的数据或变化是基于通知的机制，<strong>单次触发</strong></p><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h2><p><img src="'+h+'" alt="image"></p><h3 id="模式" tabindex="-1"><a class="header-anchor" href="#模式" aria-hidden="true">#</a> 模式</h3><ol><li>独立模式。部署单个服务</li><li>仲裁模式【集群模式】。采用 ZAB 协议保证分布式数据一致性</li></ol><h3 id="内部原理" tabindex="-1"><a class="header-anchor" href="#内部原理" aria-hidden="true">#</a> 内部原理</h3><ol><li>请求、事务、标识符。 <ol><li>请求由本地服务器完成并返回状态。</li><li>事务。数据更新有 leader 完成，以原子方式执行并具有幂等性</li><li>标识符。包含时间戳和计数器，指事务的标识符【会话 ID】</li></ol></li><li>选举过程。 <ol><li>将接收的 voteId 和 voteZxid 作为一个标识符，并获取接收方当前的投票中的 zxid，用 myZxid 和 mySid 表示接收方服务器自己的值。</li><li>如果（voteZxid &gt; myZxid）或者（voteZxid == myZxid 且 voteId &gt;mySid）,保留当前的投票信息。</li><li>否则，修改自己的投票信息，将 voteZxid 赋值给 myZxid，将 voteId 赋值给 mySid。 结论。<strong>最新的服务器</strong>将赢得选举，因为其拥有最近一次的 zxid。如果多个服务器拥有的最新的 zxid 值，其中的 <strong>sid 值最大</strong>的将会赢得选举。</li></ol></li><li>ZAB 协议【状态更新原子广播协议，类似于两阶段提交】。 <ol><li>群首向所有追随者发送一个 PROPOSAL 消息 p。</li><li>当一个追随者接收到消息 p 后，会响应群首一个 ACK 消息，通知群首其已接受该提案（proposal）。</li><li>当收到仲裁数量的服务器发送的确认消息后（该仲裁数包括群首自己），群首就会发送消息通知追随者进行提交（COMMIT）操作。</li></ol></li><li>观察者【配置中增加 observer】 <ol><li>提高读请求的可扩展性。</li><li>跨多个数据中心部署。</li><li>不参与选举。</li></ol></li><li>服务器 <ol><li>独立服务器</li><li>群首服务器【leader】，负责状态更新。持久化事务的磁盘中</li><li>追随者和观察者服务器。追随者服务器用于接收和处理客户端请求和处理 leader 服务器的事务；观察者服务器不需要去人消息也不处理事务，只用于查询</li></ol></li><li>本地存储 <ol><li>日志和磁盘。通过日志来持久化事务，<strong>写事务日志是写请求操作的关键路径</strong>。</li><li>快照。zookeeper 数据树的拷贝副本。</li></ol></li><li>服务器与会话 <ol><li>由 leader 服务器来跟踪和维护 session</li><li>leader 每半个 tick 发送一个 ping 信息给 follower</li></ol></li><li>监视点【一次性触发】</li><li>客户端</li><li>序列化 采用 Jute 来做序列化</li></ol><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料" aria-hidden="true">#</a> 资料</h2>',17),g={href:"https://zookeeper.apache.org/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://zhuanlan.zhihu.com/p/134549250",target:"_blank",rel:"noopener noreferrer"},x={href:"https://blog.csdn.net/qq_25934401/article/details/84345905",target:"_blank",rel:"noopener noreferrer"};function f(m,u){const i=d("ExternalLinkIcon");return a(),t("div",null,[p,e("ol",null,[e("li",null,[e("a",g,[l("zookeeper 官网"),r(i)])]),e("li",null,[e("a",_,[l("zookeeper 实践"),r(i)])]),e("li",null,[e("a",x,[l("zookeeper 监控"),r(i)])])])])}const z=o(c,[["render",f],["__file","index.html.vue"]]);export{z as default};
