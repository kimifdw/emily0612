import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as r,a as e,b as t,d as l,r as a}from"./app.59944050.js";const i={},c=e("h2",{id:"linux",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#linux","aria-hidden":"true"},"#"),t(" LINUX")],-1),d=e("ul",null,[e("li",null,[e("strong",null,"Q1"),t(" 使用 Linux epoll 模型的 LT 水平触发模式，当 socket 可写时，会不停的触发 socket 可写的事件，如何处理？")]),e("li",null,[e("strong",null,"A1"),t(" 向 socket 写数据时直接调用 send()发送，当 send()返回错误码 EAGAIN，才将 socket 加入到 epoll，等待可写事件后再发送数据，全部数据发送完毕，再移出 epoll 模型，改进的做法相当于认为 socket 在大部分时候是可写的，不能写了再让 epoll 帮忙监控。上面两种做法是对 LT 模式下 write 事件频繁通知的修复，本质上 ET 模式就可以直接搞定，并不需要用户层程序的补丁操作。")])],-1),u=e("h2",{id:"netty",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#netty","aria-hidden":"true"},"#"),t(" NETTY")],-1),h=e("li",null,[e("strong",null,"Q1"),t(" Why do we really need multiple netty boss threads?")],-1),_=e("strong",null,"A1",-1),p={href:"https://stackoverflow.com/questions/34275138/why-do-we-really-need-multiple-netty-boss-threads",target:"_blank",rel:"noopener noreferrer"},f=e("h2",{id:"java",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#java","aria-hidden":"true"},"#"),t(" java")],-1),b=e("li",null,[e("strong",null,"Q1"),t(" Java nio 在 Linux 系统下的 epoll 空轮询问题, select 轮询事件返回数量为 0，NIO 照样不断的从 select 本应该阻塞的"),e("code",null,"Selector.select()/Selector.select(timeout)"),t("中"),e("code",null,"wake up"),t("出来，导致**CPU 100%**问题")],-1),m=e("strong",null,"A1",-1),k={href:"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302",target:"_blank",rel:"noopener noreferrer"};function x(v,g){const o=a("ExternalLinkIcon");return s(),r("div",null,[c,d,u,e("ul",null,[h,e("li",null,[_,t(" multiple boss threads are useful if we share NioEventLoopGroup between different server bootstraps "),e("a",p,[t("stackoverflow"),l(o)])])]),f,e("ul",null,[b,e("li",null,[m,t(" 升级到高版本的 jdk 或者使用 netty 来实现 "),e("a",k,[t("java bug"),l(o)])])])])}const L=n(i,[["render",x],["__file","index.html.vue"]]);export{L as default};
