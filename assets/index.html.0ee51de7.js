import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as r,a as i,b as o,d as n,e as t,r as h}from"./app.59944050.js";const d="/assets/c2.f926e6bd.png",c="/assets/seprate.3fde3180.png",s={},p=t('<h1 id="java-即时编译器原理解析及实践" tabindex="-1"><a class="header-anchor" href="#java-即时编译器原理解析及实践" aria-hidden="true">#</a> Java 即时编译器原理解析及实践</h1><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>即时编译器将代码编译优化成本地代码，来获取更高的执行效率</p><h2 id="编译器" tabindex="-1"><a class="header-anchor" href="#编译器" aria-hidden="true">#</a> 编译器</h2><h3 id="client-compiler" tabindex="-1"><a class="header-anchor" href="#client-compiler" aria-hidden="true">#</a> Client Compiler</h3><blockquote><p>C1 编译器。注重启动速度和局部的优化</p></blockquote><ol><li>局部简单可靠的优化</li><li>将字节码构造成高级中间标识</li><li>将 HIR 转换成低级中间标识，最终生成机器码</li></ol><h3 id="server-compiler" tabindex="-1"><a class="header-anchor" href="#server-compiler" aria-hidden="true">#</a> Server Compiler</h3><ol><li>C2 编译器</li></ol><p><img src="'+d+'" alt="image"></p><ol start="2"><li>Graal 编译器【JDK9 以后】</li></ol><h3 id="分层编译" tabindex="-1"><a class="header-anchor" href="#分层编译" aria-hidden="true">#</a> 分层编译</h3><ol><li>解释执行</li><li>执行不带 profiling 的 C1 代码</li><li>执行仅带方法调用次数及循环回边执行次数 profiling 的 C1 代码</li><li>执行带所有 profiling 的 C1 代码</li><li>执行 C2 代码 <img src="'+c+'" alt="image"></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>C1 的编译速度更快，C2 的编译质量更高</p><h2 id="编译优化" tabindex="-1"><a class="header-anchor" href="#编译优化" aria-hidden="true">#</a> 编译优化</h2><h3 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析" aria-hidden="true">#</a> 逃逸分析</h3><blockquote><p>一种确定指针动态范围的静态分析，可以分析在程序的哪些地方可以访问到指针</p></blockquote><ol><li>锁消除。</li><li>栈上分配。</li><li>部分逃逸分析。</li></ol><h3 id="loop-transformations" tabindex="-1"><a class="header-anchor" href="#loop-transformations" aria-hidden="true">#</a> Loop Transformations</h3><ol><li>循环展开 <blockquote><p>循环转换技术，试图以牺牲程序二进制码大小为代价来优化程序的执行速度，一种用空间换时间的优化手段</p></blockquote></li><li>循环分离 <blockquote><p>把循环中一次或多次的特殊迭代分离出来，在循环外执行</p></blockquote></li></ol><h2 id="实践" tabindex="-1"><a class="header-anchor" href="#实践" aria-hidden="true">#</a> 实践</h2><ol><li>jvm 参数调整 <ul><li>-XX:+TieredCompilation：开启分层编译，JDK8 之后默认开启</li><li>-XX:+CICompilerCount=N：编译线程数，设置数量后，JVM 会自动分配线程数，C1:C2 = 1:2</li><li>-XX:TierXBackEdgeThreshold：OSR 编译的阈值</li><li>-XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值</li><li>-XX:TierXCompileThreshold：开启分层编译后的编译阈值</li><li>-XX:ReservedCodeCacheSize：codeCache 最大大小</li><li>-XX:InitialCodeCacheSize：codeCache 初始大小</li></ul></li><li>JITwatch 分析 <ul><li>-XX:+UnlockDiagnosticVMOptions</li><li>-XX:+PrintCompilation</li><li>-XX:+PrintInlining</li><li>-XX:+PrintCodeCache</li><li>-XX:+PrintCodeCacheOnCompilation</li><li>-XX:+TraceClassLoading</li><li>-XX:+LogCompilation</li><li>-XX:LogFile=LogPath</li></ul></li><li>使用 Graal 编译器</li></ol><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料" aria-hidden="true">#</a> 资料</h2>',24),m={href:"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html",target:"_blank",rel:"noopener noreferrer"};function u(C,X){const e=h("ExternalLinkIcon");return l(),r("div",null,[p,i("ol",null,[i("li",null,[i("a",m,[o("Java 即时编译器原理解析及实践"),n(e)])])])])}const _=a(s,[["render",u],["__file","index.html.vue"]]);export{_ as default};
