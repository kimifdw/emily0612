import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as n,c as o,a as e,b as l,d as t,e as r,r as a}from"./app.59944050.js";const d="/assets/sds-struct.5cb30085.png",h="/assets/sds-mem-structure.b2ee6830.png",A="/assets/dict-structure.acdfb2ef.png",c="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcwAAAAaCAIAAAC1qftXAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAABepJREFUeF7tWjtuIzEM3b1u2tRp0qVN6dKNj2DAVW5gwIDPECSX8OozmiEpakTNxxlvXpBms7JEvkc+UpT/3m63P/gBAkAACACBlRBwIosfIAAEgAAQWAmBPyvti22BABAAAkDAjwqAAhAAAkAACKyHAER2PWyxMxAAAkAAnSxiAAgAASCwJgLoZNdEF3sDASDw6xGAyN4/BK6755fd5f7n4kQgAAR+AAGDyH59vO6vy5h2OTw9v7jf19N32tApzuFs2/2834Y2KV44B+yOCJH1//SwvH182nBoX6UdoXvRvvdqn9gK3bqDdrpXA+iOG2+Ei8/TexSQeT3KvbkbF9koB9fj6Xp8o8pYpNehQARUX8bXNDg8mWn3wapV1NZ2L5pEVoPFVTIqsu6f5toTtjPAKI4IH7N4qpjrBLqpJLj17XV6U3RnIBgA18P/26XSPI2YJ66Pz8XkwMgauztxUe9knUtPz+/Hrzq1fuWQe6l7kq2rSGwfrMeuQHWnME2M+ZzarljHnnoB8mLE/3LzwHXLhsT2fzTqLPNi2F/WTypPASLy251LLEmwFEtxroDeZVuPH4zs85YZI4Q7U0Ypsjme/h7zkSAd7PGO2HQ2uEwcsRyh001DJfrr/jJEJgmbqXS7LfujCWW7UwqzwKxOtxcvDhSrlDSff2xeVOXCLRDODoCwRMu4KDo7lYty6kmRzSJK8cKrF8nHISDvwcVinayPPL1bue54NmadbJK/vj8iikMBzSoY6Sb6z5YLddnCoX4U12Qzk6wHHGttxGKlFGtt5s1HT628ldec9/yz9U5Ww5MouLwQGMpApsUNR2h0p1BJvhBgJf5T6CYQectDPBNhopqe0e3R6ADvrRpckOA3SE+9u7GtsHBRcNbXFd59e23qupbkWtnZUJZqVxl76nFjlIhSvSDRK7hbnYt6J+tTvQLQiJXuv2Q7Vh4X9M67T8V4ZQItmRb9TpTyWNYKTRbvtUVsjngh64R20VZElrY8tI+2imxyp3i7LMucL+biba0qsiU8SU8nbwNEWfJMV9Km5Yixmtof1jt1OeQ3lVa6+3sGvQmRcO3DUpvPqNU9/VGhIzZWNemx6Wd9lZGLgrOqyGbXrDFng84Wrz5tqccCQ4sozQuannmqrsuFQWTrDPoVaiHSYksZF5zjEVQFYs5cDlQpFJEtxagmtZPLqWwJg7H1TpYo4L07WbUuWkQ2x5M3d0zIJnSyqhIVjjCJrA88X4/Pe5nzE+hWJ9SzRNYrqTPs+7gXr5qrd0951spOVuNilsgWnZ3eyaqpJ0U2C9pGkV2di8VEttNZMQTURLDUyfYXtBAfvnk88syR11U+ksuiitarBhxlydVapILI8uv58DpE7lbBSlMna5CwzmU+kw2zJ22YWxVZFc+CAmZ3z2Ip5nNANkUd7NeaZY1uzS9P0MeORdpUutlgsbOuLLIZ3YVod1PO3fB1mtgFm96+AnRiXhSeOsRBIQAsTw5VLkZElu+vD8d8UyWdncqFw6mQetm4QI7UNC+GmXi4X/aBZOXC1mrqq5YUWS49dMzc3RTEdSy9XaQnI36bUDqR/M2EXBZiENAj+rDI0rWCGCGJPd+RId3wzNX32sPR8uHLv+xFY+gAocsfPuDv8kfL9lGjh6DnIIf4047QuCDPPtnEjZE759sFGWX0BsMKsKS7NPWWeTKDbhY/kdmS7ki6S48Bcmje8KK9uMh6f6idWvqkrKGzERpCUZ4KXGQvBDO4UFJPSZ/oUXp27kVA8SItc1+XSl8bbeBiQyI7xxT+Wc7xcvtip/8NAfXNcDtOll9it2PjYpb8KmfNqC3cyZrPHVnYtcA/+V3CJdzAHqsj0LW6ti+6rW5NdkBsnWxfdLu/dQuf+KucbcRugyLb6AGWAwEgAAQ2jABEdsPkwDQgAAQeHwGI7ONzCA+AABDYMAIQ2Q2TA9OAABB4fAQgso/PITwAAkBgwwhAZDdMDkwDAkDg8RGAyD4+h/AACACBDSMAkd0wOTANCACBx0fgH2Zg4OWOdUn6AAAAAElFTkSuQmCC",u="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAUCAIAAADtIHQIAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAABC1JREFUaEPtWUtqMkEQnv8KuYCQjSDiWYTcItuA4CKb7Nxm6S5B8AiCK28gETxDSC7hX93Vj6qe6nlFx3HsYRbSU/2oqu+rR/vvdDpl6UkWuFsLAAHSkyxwtxbI7lbz21Qc/NX+e5umqnbqRIBqduqKVPvo7zlCeq5e+7j93r4/L3bfl9o4EeDMlr0CARREXl7hXR7OrMyVljsuX9Z7u3enCbAfjibDr9pFVJldD+vnz2OB0P6zu76OEgAc+bb9LVO9+fdmRoFZtU51aS20/owATS3yu1lUQYnLAINpNv6oC+UuE+Bn90biSFMz1p4nEwBwRvL4cbnYbWBEhe33zY/eQ5F+Bz7Tgzb+KR3YCMMrfCW1QUiA3FzA7nJrF/QBRgGlIge4FvrMeDx7jIItUNJt5LIWMYs6iVnQWACYwNYHO8lbuJNQkyoilXJAEwBwnGXTlS+HPp7MLeZo/qC75MF0MpyZwcfZHkYeZhN204mSX/PH0Xw4xS86OcBSdpHstBrrwcjjXfZqMwCxCRqZaeqgkhPDHZSwz6W1sdxogkAAhRuW0ZRjDBTgiF4xQwYbZUkgdGIE9EEw5gQQ5mrMoTngqyWeVjJ3QkH1UIafBBUUtxCSjFMHp+i5RIxnAM5zaQuvTm6vUnoj+hHT5tUgRtwrlGtiQH4wOIav2dPACOcygPpqMwlAX80lMmZEBhZxilQCUXcXZPswRStSMV83QnWNSQEBRAdQB9vfeZ0DrpsoCwuiPu6HORwzijSXmCacazgQ7TUFLXwIxyBtCWBjvNtCqGeYkwy+JZugZjkCSFsYH0sVnY6OsZIaQnJY+YSh3RLAFkgwpZAAPt4bRsGCSDCVRnTDgDHIpDsfCt0hCRhU3AkkdbAI+j1RzCBDJ5bW+sOKGYAWOfq3SADRbYe1Mhloxb+GBMjNLSBAgwwgNgPSFi0QIFIAKP83yAAOr/SCiHQItQmgKh/FitXYVllSQKUAcL9JDVOUASJiJnxcNQP48Mx6AFuZuQJAIECuULFmUy3EHgp6fueTK4HCxBchQClEvLdYDyD1WNIW0vqkBLLc8z2rDmakci3NAFyAgKthD8CKHBPF4wTgCYSUT5w/qoVwTbZEAG9PnRwwfnlDkbKZlYt6qYhYV3oAVJeAw6c/zwrx5otUMrRPDSBC0x/rqnnqFAnwl1sgWgUhGyMcy6V77DqCBtcquzzYpEGbwqIqi3bPriP/yy0QrYIQtREC6B4XH9IEY//AXiXmCicJ/6YKxSsQDwan2npDbxHDGw5JrFO3QFzls1zzRax4h8MsdoT9fZk92vkjLCiryg51y9+r/BGWCHBeD5OMWrvbuzQBTDKhd6znVb5rq1UhQNfOfM/nuTQBxPX7bPBEgD57N+lWaoFEgFITJYE+WyARoM/eTbqVWiARoNRESaDPFvgPu+7hhKOQ1osAAAAASUVORK5CYII=",p={},g=r('<h1 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h1><h2 id="keys" tabindex="-1"><a class="header-anchor" href="#keys" aria-hidden="true">#</a> keys</h2><ol><li>二进制安全，空字符串也是有效的键</li><li>规则 <ul><li>键不能太长。可以使用 SHA1 来对大值进行处理</li><li>键也不能太短。</li></ul></li></ol><h3 id="自动创建和删除键" tabindex="-1"><a class="header-anchor" href="#自动创建和删除键" aria-hidden="true">#</a> 自动创建和删除键</h3><ol><li>规则。 <ul><li>添加到聚合数据类型时，如果目标键不存在，则在添加元素之前会创建一个空的聚合数据类型。</li><li>删除聚合数据类型中的元素时，如果该值保持为空，则键将被自动销毁</li><li>调用带空键的只读或写命令删除元素，总会产生与键保持空的聚合类型相同的结果</li></ul></li></ol><h2 id="expires" tabindex="-1"><a class="header-anchor" href="#expires" aria-hidden="true">#</a> expires</h2><ol><li>到期时间分辨率始终为<strong>1 毫秒</strong></li></ol><h3 id="lru-算法" tabindex="-1"><a class="header-anchor" href="#lru-算法" aria-hidden="true">#</a> LRU 算法</h3><ol><li>配置<code>maxmemory</code>来限制 redis 的内存使用，超过部分执行策略来释放内存</li></ol><h2 id="外部数据结构" tabindex="-1"><a class="header-anchor" href="#外部数据结构" aria-hidden="true">#</a> 外部数据结构</h2><h3 id="string-字符串" tabindex="-1"><a class="header-anchor" href="#string-字符串" aria-hidden="true">#</a> STRING（字符串）</h3><ol><li>二进制安全，最大长度为 512MB</li><li>编码为 int/raw/embstr <ul><li>embstr。字符串对象的长度小于<strong>44</strong>字节，使用 embstr 对象。创建只会分配一次内存，使用 malloc 方法一次分配</li><li>raw。需要使用两次 malloc 方法，两个对象头在内存地址上一般不是连续的</li></ul></li><li>sds（Simple Dynamic String）字符串结构。string 的底层实现 <ul><li>可动态扩展内存</li><li>二进制安全</li><li>兼容传统的 C 语言字符串类型</li></ul></li></ol><h3 id="list-列表" tabindex="-1"><a class="header-anchor" href="#list-列表" aria-hidden="true">#</a> LIST（列表）</h3><ol><li>根据插入<strong>顺序排序</strong>的字符串元素的集合，基于<strong>双向链表</strong>实现。插入或删除快，查找慢。</li><li>方法 <ul><li><code>LPUSH</code>命令将新元素从列表的<strong>头部</strong>添加</li><li><code>RPUSH</code>命令将新元素从列表的<strong>尾部</strong>添加</li><li><code>LTRIM</code>命令限制列表可查看的数据量</li><li><code>BRPOP</code>和<code>BLPOP</code>。仅当将元素添加到列表中或用户指定的超时时间到时，能等待元素到来而不是采用轮训的方式。</li></ul></li><li>列表的最大长度是 2^32-1 个元素（一个列表多达 40 多亿的数据）</li><li>编码为<strong>ziplist</strong>或<strong>linkedlist</strong><ul><li>ziplist。压缩链表，节省内存空间【数据量不能太大】</li><li>linkedlist。双向链表</li></ul></li></ol><h3 id="hash-哈希" tabindex="-1"><a class="header-anchor" href="#hash-哈希" aria-hidden="true">#</a> HASH（哈希）</h3><ol><li>由与值相关联的字段组成的映射。字段和值都是字符串</li><li>方法 <ul><li><code>HINCRBY</code>。按增量递增存储在键处存储的哈希中字段中存储的数字，返回的是增加操作后的值</li></ul></li></ol><h3 id="set-集合" tabindex="-1"><a class="header-anchor" href="#set-集合" aria-hidden="true">#</a> SET（集合）</h3><ol><li>唯一、未排序的字符串元素的集合。结构底层也为 dict</li></ol><h3 id="zset-排序集合" tabindex="-1"><a class="header-anchor" href="#zset-排序集合" aria-hidden="true">#</a> ZSET（排序集合）</h3><ol><li>每个字符串元素都与一个浮点数字值相关联</li></ol><h3 id="bit-arrays-位图" tabindex="-1"><a class="header-anchor" href="#bit-arrays-位图" aria-hidden="true">#</a> Bit arrays（位图）</h3><ol><li>像位数组一样处理字符串</li></ol><h3 id="hyperloglogs-概率数据结构" tabindex="-1"><a class="header-anchor" href="#hyperloglogs-概率数据结构" aria-hidden="true">#</a> HyperLogLogs（概率数据结构）</h3><ol><li>用于估计集合的基数</li></ol><h3 id="streams-流" tabindex="-1"><a class="header-anchor" href="#streams-流" aria-hidden="true">#</a> streams（流）</h3><ol><li>抽象日志数据类型，仅追加 map 数据类型的集合</li></ol><h2 id="内部数据结构" tabindex="-1"><a class="header-anchor" href="#内部数据结构" aria-hidden="true">#</a> 内部数据结构</h2><h3 id="sds" tabindex="-1"><a class="header-anchor" href="#sds" aria-hidden="true">#</a> sds</h3>',28),b=r('<li>内部结构 <img src="'+d+'" alt="image"></li><li>内存结构 <img src="'+h+'" alt="image"></li><li>按字符串的使用大小来设置多个头部格式，不按动态头部来设置 <ul><li>header。 <ol><li>len: 表示字符串的真正长度（不包含 NULL 结束符在内）。</li><li>alloc: 表示字符串的最大容量（不包含最后多余的那个字节）。</li><li>flags: <strong>总是占用一个字节</strong>。其中的最低 3 个 bit 用来表示 header 的类型</li></ol></li><li>字符串数组。</li></ul></li><li>动态扩容 <ul><li>原则。新长度=(新增加长度+原长度)&gt;(1024 <em>1024)?(新增长度+原长度) + (1024</em> 1024) :(新增加长度+原长度) * 2。可能会涉及对 header 类型的修改</li><li>具体实现。 <ol><li><code>sdsMakeRoomFor</code>方法实现扩容。</li><li><code>sdscatlen</code>方法实现扩容策略。</li></ol></li></ul></li><li>与 C 语言字符串的区别 <ul><li>获取字符串长度：O(1)</li><li>杜绝缓冲区溢出</li><li>减少修改字符串时带来的内存重分配次数</li></ul></li>',5),f={href:"http://zhangtielei.com/posts/blog-redis-sds.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://blog.csdn.net/weixin_40318210/article/details/85316315",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/redis/redis/blob/unstable/src/sds.c",target:"_blank",rel:"noopener noreferrer"},k={href:"https://github.com/redis/redis/blob/unstable/src/sds.h",target:"_blank",rel:"noopener noreferrer"},S={href:"https://blog.csdn.net/qq193423571/article/details/81637075",target:"_blank",rel:"noopener noreferrer"},B={href:"https://zhuanlan.zhihu.com/p/269496479",target:"_blank",rel:"noopener noreferrer"},w=e("h3",{id:"dict",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dict","aria-hidden":"true"},"#"),l(" dict")],-1),x=e("li",null,[e("p",null,"一个用于维护 key 和 value 映射关系的数据结构【基于哈希表的算法】，为解决算法中的查找问题。")],-1),z=e("li",null,[e("p",null,[l("特点。采用"),e("strong",null,"增量式重哈希"),l("的方法，避免一次性对所有 key 进行重哈希，在查找、插入、删除时都会触发重哈希")])],-1),Q=e("li",null,[e("p",null,[l("数据结构。定义两个哈希表用于重哈希 "),e("img",{src:A,alt:"image"})])],-1),R=e("li",null,[e("p",null,"扩容条件。当 hash 表中元素的个数等于第一维数组的长度时，触发扩容，扩容大小为原数组大小的 2 倍")],-1),C=e("li",null,[e("p",null,"缩容条件。元素个数低于数组长度的 10%")],-1),D=e("p",null,"资料",-1),U={href:"http://zhangtielei.com/posts/blog-redis-dict.html",target:"_blank",rel:"noopener noreferrer"},I=e("h3",{id:"ziplist",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#ziplist","aria-hidden":"true"},"#"),l(" ziplist")],-1),E=r('<li><p>定义。是经过特殊编码的双向链表，存储字符串和整数值，整数被编码为实际整数，而不是一系列字符，按小端存储。是一个连续的内存空间，将一些必要的偏移量信息记录在节点里，能跳到上一个节点或下一个节点</p></li><li><p>内存结构 <img src="'+c+'" alt="image"></p><ul><li><p><code>zlbytes</code>。表示 ziplist 占用的字节总数（4 个字节）</p></li><li><p><code>zltail</code>。表示 ziplist 表中最后一项（entry）在 ziplist 中的偏移字节数。可以很方便地找到最后一项（不用遍历整个 ziplist），从而可以在 ziplist 尾端快速地执行 push 或 pop 操作。</p></li><li><p><code>zllen</code>。数据项（entry）的个数，2^16-1（2 个字节）</p></li><li><p><code>entry</code>。真正存放数据的数据项，长度不确定</p><ol><li><p>内部结构</p><p><img src="'+u+'" alt="image"></p><ul><li><code>prevlen</code>。记录上一个节点的长度</li><li><code>encoding</code>。当前节点的编码规则</li><li><code>data</code>。当前节点的值</li></ul></li></ol></li><li><p><code>zlend</code>。结束标识，固定值（255）</p></li></ul></li><li><p>使用<code>quicklist</code>替代 ziplist 和 linkedlist。quicklist 将 linkedlist 按段切分，每一段使用 ziplist 让存储紧凑，多个 ziplist 之间使用双向指针串联起来</p></li>',3),Y=e("p",null,"资料",-1),q={href:"http://zhangtielei.com/posts/blog-redis-ziplist.html",target:"_blank",rel:"noopener noreferrer"},y={href:"https://segmentfault.com/a/1190000017328042",target:"_blank",rel:"noopener noreferrer"},P={href:"https://segmentfault.com/a/1190000016901154",target:"_blank",rel:"noopener noreferrer"},N=e("h2",{id:"资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#资料","aria-hidden":"true"},"#"),l(" 资料")],-1),L={href:"http://zhangtielei.com/posts/blog-redis-dict.html",target:"_blank",rel:"noopener noreferrer"},W={href:"https://segmentfault.com/a/1190000022381177",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.cnblogs.com/shoshana-kong/tag/redis/",target:"_blank",rel:"noopener noreferrer"},X={href:"https://redis.io/topics/data-types-intro",target:"_blank",rel:"noopener noreferrer"},v={href:"http://ifeve.com/redis-data-types/",target:"_blank",rel:"noopener noreferrer"},V={href:"http://redisbook.com/index.html",target:"_blank",rel:"noopener noreferrer"};function H(F,M){const i=a("ExternalLinkIcon");return n(),o("div",null,[g,e("ol",null,[b,e("li",null,[l("资料 "),e("ul",null,[e("li",null,[e("a",f,[l("sds 数据结构详解（推荐）"),t(i)])]),e("li",null,[e("a",m,[l("SDS 扩容"),t(i)])]),e("li",null,[e("a",_,[l("sds 源文件 sds.c"),t(i)])]),e("li",null,[e("a",k,[l("sds 源文件 sds.h"),t(i)])]),e("li",null,[e("a",S,[l("深入浅出 redis sds"),t(i)])]),e("li",null,[e("a",B,[l("全网最细节的 sds 讲解（推荐）"),t(i)])])])])]),w,e("ol",null,[x,z,Q,R,C,e("li",null,[D,e("ul",null,[e("li",null,[e("a",U,[l("dict 原理"),t(i)])])])])]),I,e("ol",null,[E,e("li",null,[Y,e("ul",null,[e("li",null,[e("a",q,[l("Redis 内部数据结构详解(4)——ziplist"),t(i)])]),e("li",null,[e("a",y,[l("redis ziplist 源码分析"),t(i)])]),e("li",null,[e("a",P,[l("redis 源码分析"),t(i)])])])])]),N,e("ol",null,[e("li",null,[e("a",L,[l("Redis 内部数据结构详解"),t(i)])]),e("li",null,[e("a",W,[l("值得一看的 35 个 Redis 面试题总结"),t(i)])]),e("li",null,[e("a",T,[l("redis 文章"),t(i)])]),e("li",null,[e("a",X,[l("redis 官方文档"),t(i)])]),e("li",null,[e("a",v,[l("redis 官方文档译文"),t(i)])]),e("li",null,[e("a",V,[l("redis 设计与实现"),t(i)])])])])}const j=s(p,[["render",H],["__file","index.html.vue"]]);export{j as default};
