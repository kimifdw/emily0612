

# Redis

## 一、Redis与MySQL双写一致性

### 1.1 一致性

**强一致性**。这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大

**弱一致性**。这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态

**最终一致性**。是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。

### 1.2 缓存模式

1. Cache-Aside Pattern【旁路缓存模式】。为了尽可能地解决缓存与数据库的数据不一致问题。

   流程：

   1. 读取。先读缓存，再去读数据库，从数据库取出数据，放入缓存，同时返回响应
   2. 写入。**先更新数据库，然后再删除缓存**

2. Read-Through/Write-Through【读写穿透】。服务端把缓存作为主要数据存储。也就是在Cache-Aside Pattern中增加了一个cache provider，由这个provider来处理缓存与数据库的交互

   

3. Write-behind【异步缓存写入】。与读写穿透类似，只是在操作数据库的时候采用**异步批量更新**数据库的方式

### 1.3 操作缓存

1. 一般采用先更新数据库再删除缓存
2. 缓存延时双删。先删除缓存-->再更新数据库-->休眠一会儿，再删除缓存
3. 删除缓存重试机制
4. 读取**binlog**异步删除缓存

### 1.4 参考文献

1. [Redis与MySQL双写一致性](https://mp.weixin.qq.com/s/c0JwYl-9prOLtNeoTTch0w)

## 二、大Key与热Key

### 2.1 定义。

大Key。以数据大小与成员数量来判定，会将含有较大数据或含有大量成员、列表数的Key【根据实际使用场景、业务场景来判断】

- 一个**STRING**类型的Key，它的值为**5MB**（数据过大）

- 一个**LIST**类型的Key，它的列表数量为**20000**个（列表数量过多）

- 一个**ZSET**类型的Key，它的成员数量为**10000**个（成员数量过多）

- 一个**HASH**格式的Key，它的成员数量虽然只有**1000**个但这些成员的value总大小为**100MB**（成员体积过大）

热Key。在某个Key接收到的访问次数、显著高于其它Key。

### 2.2 问题排查

![问题排查](/image/1.png)

### 2.3 方法处理

1. 读写分离架构

### 2.4 参考文献

1. [一文详解Redis中BigKey、HotKey的发现与处理](https://mp.weixin.qq.com/s/FPYE1B839_8Yk1-YSiW-1Q)

## 三、redis总结

### 3.1 redis数据类型剖析

#### 3.1.1 string

>  sds数据结构，采用**空间预分配**和**惰性空间**释放来提升效率。核心是空间换时间

#### 3.1.2 list

#### 3.1.3 hash

#### 3.1.4 zset

> 有序集合，底层采用跳跃表实现

#### 3.1.5 set

### 3.2 持久化方案

#### 3.2.1 rdb

1. save。手动保存，阻塞进程，直至RDB文件创建完毕
2. bgsave。与save不同的是可以不阻塞redis进程

#### 3.2.2 aof

> 命令追加的模式

### 3.3 缓存穿透、击穿、雪崩如何解决

#### 3.3.1 缓存穿透

问题。处理缓存和DB都不存在的数据时

解决方案

1. 空值缓存
2. 布隆过滤器。在有限的空间里，通过多个hash函数来定位一条数据

#### 3.3.2 缓存击穿【单个KEY】

问题。热点数据在某一时刻缓存过期，然后突然大量请求打到db中，这时如果db扛不住，可能就挂了，引起线上连锁反应。类似并发访问一些热点数据

解决方案

1. 并发问题。加分布式锁
2. 配置二级缓存【内存或借助其他缓存工具】
3. 热点数据不过期

#### 3.3.3 缓存雪崩【多个KEY】

问题。某一时间点，突然大量缓存失效，所有的请求都打到了db

解决方案。

1. 随机设置失效时间。防止在某一个时间点大批量缓存失效
2. 上锁：根据场景上锁，保护db
3. 二级缓存：同缓存击穿
4. 热点数据不过期：同缓存击穿

### 3.4 参考文献

1. [redis总结](https://mp.weixin.qq.com/s/HINQmFmkWXXhI5_D07tyBw)

## 四、排查redis查询慢的问题

### 4.1 设置Redis的慢日志阀值

```bash
# 命令执行超过5毫秒记录慢日志
CONFIG SET slowlog-log-slower-than 5000
# 记录最近1000条慢日志
CONFIG SET slow-max-len 1000
```

具体执行显示如下：

```bash
uat:0>slowlog get 5
 1)    1)   "18394"  # 慢日志ID
  2)   "1630483150"  # 执行时间
  3)   "112466"      # 执行耗时(微妙)
  4)      1)    "KEYS" # 具体执行的命令和参数
   2)    "ims:mc:unreadMsgKey*"
```

### 4.2 考虑方向

1. 大key存储【比如在慢日志中出现ZSET等】
2. 出现key集中过期的情况
3. 实例内存达到上线
4. fork耗时严重。主要是看lastest_fork_usec耗时，这个耗时表示在这段时间内整个实例是阻塞无法处理请求的时间，类似于JAVA的STW
5. 绑定CPU【如开启了AOF和RDB，则不能绑定CPU】
6. 开启AOF
7. 使用SWAP【redis使用的内存被切换到了磁盘上】，这种场景一般是出现在服务器本身内存不足而用到了swap的情况
8. 网卡负载过高

### 4.3 总结

1. 开发人员。我们需要了解Redis的**运行机制**，例如各个命令的执行时间复杂度、数据过期策略、**数据淘汰策略**等，使用合理的命令，并结合业务场景进行优化
2. 运维人员。需要了解**数据持久化**、**操作系统fork原理**、**Swap机制**等，并对Redis的容量进行合理规划，预留足够的机器资源，对机器做好**完善的监控**，才能保证Redis的稳定运行。

### 4.4 参考资料

- [x] [redis变慢，如何快速排查](https://mp.weixin.qq.com/s/paeQZMs7TrXd8oC1Pz8yYQ)

